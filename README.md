---
title: コマンドを使わずに理解するGit
tags: Git 初心者 イメージ
author: noshishi
slide: false
---

<!-- TOC -->

- [Gitとは](#Gitとは)
    - [バージョンを管理し、作業を分散する](#バージョンを管理し、作業を分散する)
    - [作業フロー](#作業フロー)
    - [完全理解の鍵はイメージ](#完全理解の鍵はイメージ)
- [かきくけこ](#かきくけこ)
    - [いろはにほへと](#いろはにほへと)
    - [ちりぬるを](#ちりぬるを)
- [さしすせそ](#さしすせそ)
    - [寿限無寿限無](#寿限無寿限無)
    - [五劫の擦り切れ](#五劫の擦り切れ)
    - [海砂利水魚](#海砂利水魚)
- [たちつてと](#たちつてと)

<!-- /TOC -->

<a id="markdown-Gitとは" name="Gitとは"></a>
## Gitとは

<a id="markdown-バージョンを管理し、作業を分散する" name="バージョンを管理し、作業を分散する"></a>
### バージョンを管理し、作業を分散する
Gitは、分散型バージョン管理システムと呼ばれるシステムの1種です。Gitは、ファイルの変更履歴（バージョン）を記録・追跡したりすることで、過去と変更後のファイルを比較し、円滑に開発作業を進めるためのツールです。また、一度に複数の開発者がファイルを編集できる環境を用意しているので、作業を分散して行うことができます。

<a id="markdown-作業フロー" name="作業フロー"></a>
### 作業フロー
まず、大元のファイルなどの保存場所（以下、リモートレポジトリ）から、手元のパソコン（以下、ローカルレポジトリ）にコピーを作って、新しいコードやファイルを追加・編集して、今度は逆に、ローカルレポジトリからリモートレポジトリへ登録する。ローカルレポジトリは、開発者の数だけあります。


<img width="600" alt="retool.png" src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2918231/22c6b2e3-aeda-44c6-8f54-3b7e80db129b.png">


<a id="markdown-完全理解の鍵はイメージ" name="完全理解の鍵はイメージ"></a>
### 完全理解の鍵はイメージ
Gitを扱う上で、重要なのは「何」から「何」へ、が「どんな作業」を行うのかを追うことが大事です。コマンドだけで操作していると、現状何が起きているかを理解できず、誤ったコマンドを打ってしまう可能性があります。



:::note info
操作する前に、「何」から「何」へ、が「どんな作業」が行われるかをイメージしよう
:::



# 新しい作業を始める

### レポジトリ
Gitにおけるレポジトリとは、ファイルを保存しておくための倉庫です。種類に分けると、リモートとローカルの二つがあります。リモートレポジトリは、ソースコードをインターネットや自社のサーバー上に置いて、みんなで共有できるような状態になっているレポジトリです。ローカルレポジトリは、ソースコード等を手元パソコンに置いて、自分だけが変更できる状態になっているレポジトリです。


### レポジトリを複製して作業開始
まず、自分の開発環境を用意します。といっても、どこでのフォルダで作業するかを決めるだけです。例えば、ホームフォルダでもいいし、普段使っているフォルダで構いません。

次に、リモートレポジトリからファイルをコピーして持ってきます。これを**clone**といいます。この段階で一緒に作業フォルダが作成されます。なので、新しいフォルダを作成しなくていいです。`git clone`というコマンドで行います。


<img width="400" alt="clone.png" src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2918231/36772bce-9111-1f50-bafd-97246035e78e.png">

今回はファイルが一つ(`first.txt`)だけのレポジトリをcloneしました。

### ファイルを変更・追加する
レポジトリのソースコードの変更は、ワーキングディレクトリ、ステージングエリアを通して行われます。実際には、我々がソースコードを変更するのは、ワーキングディレクトリです。新しく、`second.txt`というファイルを作成するとワーキングディレクトリにファイルが追加されます。

ワーキングディレクトリは、何も特殊なことはなくて、いつもパソコンで作業する時にファイルを作成する時に自分が操作しているディレクトリのことです。Gitが管理する対象のディレクトリ（今回であれば`project`）には、Gitのステージングエリアやローカルレポジトリと接続できるよと考えてもらえれば分かりやすいと思います。

<img width="400" alt="clone3.png" src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2918231/162c1db8-8271-fd4e-f702-2f77a0329564.png">


次に、ステージングエリアに変更したファイルを追加します。これを**add**と言います。変更したファイルをローカルレポジトリに反映させる前にワンクッションおくのがGitの特徴で、なぜこのクッションがあるのか後ほど詳しく説明します。`git add`というコマンドで行います。

<img width="400" alt="add.png" src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2918231/e975ecbf-c65f-f9ab-6dec-75984de363d6.png">

そして、ステージングエリアで追加された内容をローカルレポジトリへ登録します。これを**commit**と言います。`git commit`というコマンドで行います。ちなみに、コミットする際にコメントがかけます。今回だったら新しいファイルを追加したので、`git commit -m 'add second.txt'`とでもしておきましょう。

<img width="400" alt="commit.png" src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2918231/f8908fd7-72b1-51d7-4aa6-c742b56a4fac.png">

:::note warn
コミットをすると、レポジトリにコミットオブジェクトが作成されます。なので、厳密に言えばファイルを追加しているのではなく、ファイルの状態（スナップショット）を登録していることになります。詳しくは、後ほど説明します。
コミットオブジェクトについては、[Gitのオブジェクトの中身](https://zenn.dev/kaityo256/articles/objects_of_git)を参考にしてください。
:::


### リモートレポジトリを変更する
上記作業で、自分の手元の作業は終わりました。最後に行うのが、ローカルレポジトリの変更をリモートレポジトリへ反映させることです。これを**push**と言います。リモートレポジトリに対して行うcommitだと考えると分かりやすいかもしれません。

<img width="400" alt="push.png" src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2918231/d57789fe-08f2-3234-ec5a-bf1457a6cb6d.png">

### 差分をみる
`diff`というコマンドを使うと作業内容を簡単に確認することができます。そもそもvscodeの拡張機能があれば特に使用することはないかもしれませんが、コミットオブジェクト同士を比較することもできるので、覚えて損はないです。
`add`する前にワーキングディレクトリで作業中の時、元々のワーキングディレクトリとの変更点をみる`git diff`、`add`した後に元のワーキングディレクトリとの変更点を見るなら`git diff --stage`、コミットを比較するなら`git diff <commit> <commit>`など。

### まとめ
一度`clone`して,作業ごとに`add`,`commit`,`push`が基本的な作業の流れです。
![basic.gif](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2918231/9dccfc0e-f2d9-5405-29c4-890f34894308.gif) 

:::note
リモートレポジトリを複製して、自分の開発環境で作業を行う。ローカルレポジトリを更新できたら、今度はリモートレポジトリを更新する。
:::



# ブランチ
ブランチは、ファイルの変更や追加を複数の分岐に分けて作業を行うためのものです。今まで行ってきたのは、実は`main`ブランチで作業を行なっていました。なぜブランチを作るかというと、`main`ブランチで保存しているファイルは、現在進行形で使用されているからです。なので、Gitでは、基本的に別のブランチを作って（生やして）作業を行なっていきます。

<img width="400" alt="brancha.png" src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2918231/76f507a4-232e-894e-e01f-328ab7138577.png">

本文・・・

<img width="400" alt="remotes.png" src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2918231/9c014980-79e5-bba6-c3d8-c8f6a237178d.png">



本文・・・

### 新しいブランチを作る
`develop`というブランチを作ってみます。ブランチはレポジトリ内で管理されています。`git branch <new branch>`や<git checkout -b <new branch>というコマンドで作ることができます。前者はブランチを作ったけどそのブランチに移動せず、後者はブランチを作ってそのブランチに移動します。

<img width="400" alt="cretae_branch.png" src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2918231/a7f499f9-bf5e-0c58-1a35-59cd3e2a4c30.png">

ちなみに、なぜ「生やす」とも呼ばれるかというと、どのブランチから派生させるかを決めることができるからです。派生元を`git checkout -b <new branch> <from branch>`として指定することができます。指定しなければ現在作業しているブランチが`<from branch>`になります。


:::note warn
ブランチは、実はコミットオブジェクト（厳密にいうとコミットオブジェクトのハッシュ値）のポインタです。新しブランチを生やすということは、派生元のブランチがポインタしているコミットオブジェクトを、新しいブランチもポインタすることを意味します。
:::

### ブランチで作業を進める
作業するブランチを移動することを`checkout`すると言います。現在作業しているブランチのポインタを`HEAD`と呼びます。つまり、`main`ブランチから`develop`ブランチ移動するというのは`HEAD`を変えることを意味します。

<img width="400" alt="checkout_branch.png" src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2918231/4368a590-f07f-5733-e0a4-438c31eacfd5.png">

現在は、`Atr3ul`というコミットを両方のブランチが指しています。先ほどは`second.txt`を`main`ブランチでコミットして追加したので、`f27baz`というコミットからひとつ前に進んでいる状態です。ここから、`develop`ブランチで`second.txt`を変更し、新しいコミットを行うとします。

<img width="400" alt="in_branch.png" src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2918231/1ae0aa22-4c8d-411b-b20e-c29047dcdb4d.png">


そうすると図のように、`develop`ブランチは`m9sgle`というコミットを作成し、そのコミットをポインタすることになりました。

現在のHEADの位置（作業ブランチの位置）やファイルがどの段階まで作業を進めたか、あるいは誰がその作業を行なっているかの状態を`status`と言います。ちなみに`git status`をすると、詳細な情報が確認できます。

### （余談）Git FlowとGitHUb Flow
ブランチの生やし方や運用は、開発チームごとによって異なると思います。一方で、プログラミングの命名規則のように、Gitのブランチの生やし方には一般的なモデルが存在します。簡単に２つを紹介します。こんなものがあるんだな程度でいいと思います。

「Git Flow」は、かなり複雑に入り組んだ構造をしています。本来のあるべきGitの使い方みたいなモデルかなと思います。

<img width="400" alt="git_flow.png" src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2918231/45c382b6-e6a0-7e06-7ed7-dd0bbc6b8def.jpeg">

[【図解】git-flow、GitHub Flowを開発現場で使い始めるためにこれだけは覚えておこう](https://atmarkit.itmedia.co.jp/ait/articles/1708/01/news015.html) より

各ブランチの定義
`master`:プロダクトとしてリリースする用のブランチ。※このブランチ上での作業は行わない
`develop`:開発用ブランチ。コードが安定し、リリース準備ができたらreleaseへマージする。※このブランチ上での作業は行わない
`feature`:機能の追加用。developから分岐し、developにマージする。
`hotfixes`:リリース後の緊急対応（クリティカルなバグフィックスなど）用。masterから分岐し、masterにマージすると共にdevelopにマージする。
`release`:プロダクトリリースの準備用。リリース予定の機能やバグフィックスが反映された状態のdevelopから分岐する。リリース準備が整ったら、masterにマージすると共にdevelopにマージする。

「GitHUb Flow」は、Git Flowをやや簡略化したモデルです。

<img width="400" alt="github_flow.png" src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2918231/f42c5209-2974-5035-52f7-27b19c860677.jpeg">

[【図解】git-flow、GitHub Flowを開発現場で使い始めるためにこれだけは覚えておこう](https://atmarkit.itmedia.co.jp/ait/articles/1708/01/news015.html) より

見ての通り、`main`と`feature`だけで構成されており、主な違いとしてプルリクエスト（下のプルで説明）というクッションでブランチ間の統合を行います。

### まとめ
基本的にmain上で作業することはないので、行いたい作業単位でブランチを作成し、新しいコミットを作成していきましょう。

![branch_anime.gif](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2918231/f5158fea-ea6c-a033-11f7-27a9b152539c.gif)



:::note
ファイルの変更や追加は、行う作業ごとに新しいブランチを生やして行う。
:::

# マージ
マージは、枝分かれたブランチ同士を統合することです。基本的に、`main`ブランチや`develop`ブランチに対して統合を行なっていきます。注意点は、「どのブランチ」が「どのブランチ」を統合(吸収)するかの主語を間違わないことです。必ず、派生元のブランチに（HEAD）移動して、派生先のブランチからの統合を行うことになります。

### ファストフォワードでマージする
`feature`ブランチが、派生元である`develop`ブランチのひとつ後のコミットを指しているとき、`feature`ブランチは、`develop`ブランチの`fast-forward`になっていると言います。

[図の挿入]

このときマージを行うと、`develop`ブランチは、ただひとつ先のコミットに進めるだけになります。　<git merge feature>で行うことができます。

[図の挿入]

### ノーファストフォワードとオートマージ
もし、`develop`ブランチが違うコミットやマージによって、全くことなるコミットになっていたらどうなるでしょうか？これを`no fast-forward`と言います。この場合、差分を確認して競合している変更点がなければ`Automatic merge`と呼ばれるマージを行うことができます。

[図の挿入]

この場合、マージコミットというコミットがつくられます。マージで作られたコミットという意味だけなので深くは考えなくて大丈夫です。

### コンフリクトに対処する

`no fast-forward`状態で、もしオートマージできない状態であることを`conflict`と言います。この場合は、手動でコンフリクトをしている内容を修正し、コミットを行います。

[図の挿入]

初心者が恐怖のコンフリクトですが、これを覚えればもう怖くありません。


### 不要なブランチは削除する
統合されたブランチは、基本お役御免なので、削除していきます。ブランチを放置しておくと、削除したいブランチから他のブランチに移動して、`git branch -d <branch>`すればおさらばです。ちなみに、削除されたらそのブランチのコミットオブジェクトは無くなるのかというとそうではありません。マージしたブランチにしっかりと引き継がれています。`git log`を使用すると、過去のすべてのコミットを越連できます。


# ローカルレポジトリを最新にする
### 最新の状況を確認する
[図の挿入]

### 最新の状態に更新する
プル = フェッチ + マージ

[図の挿入]

### プルのコンフリクトに対処する

### プルリクエストの正体

[図の挿入]

# リベース
### ログでコミット履歴を確認する

[図の挿入]

### 複数のコミットを繋げる

[図の挿入]

### リベースのコンフリクトに対処する


# 便利な機能
### リバートとリセット
「リバート(revert)」は
[図の挿入]

「リセット（reset）」
[図の挿入]


### スタッシュ


### チェリーピッキング

別のブランチのコミットをとってくる
[図の挿入]

# 終わりに
### Git以外のソースコードの管理
Gitと同じ歴史を持ったMercurialというサービスがあります。特徴は、Gitのような柔軟性を犠牲に非常にシンプルなコマンドラインインターフェース(CLI)を採用していることです。最近だと、このMercurialをベースにMeta社がSaplingという新しいソースコード管理システムをオープンソースで公開されましたね。また今度、ちょっと触ってみて感想を書いてみたいなと思います。

### リモートレポジトリの居場所
リモートリポジトリ用のサーバーを貸してくれるサービスをホスティングサービスと言います。代表的なものであれば、GitHub, Bitbucket、プライベートに使用するAws Code Commitなどがあります。GitとGit Hubは、全く別物です。ちなみに、上で書いた通り、リモートリポジトリ用のサーバーは自分達のサーバーでも大丈夫です。

### お礼
最後まで読んでいただきありがとうございました。この記事を作成を通して、本当の意味でGitと向き合えたなと思います。まだまだ見習いエンジニアなので、なんとか小手先で解決したくなるGitのコマンドでしたが、最近ではイメージが湧いてくるので湖面度が楽しくなってきました。この記事が、誰かにとって同じような体験を提供できれば幸いです。[]()でも公開しています。GitHub上ではコマンドあり版も記載していく予定なので、もしよければご覧ください。ついでに、starなんかをいただけると泣いて喜びます。

# 参考サイト
- [Git Documentation](https://git-scm.com/doc)
- [Learn git concepts, not commands](https://dev.to/unseenwizzard/learn-git-concepts-not-commands-4gjc)
- [図解 Git](https://marklodato.github.io/visual-git-guide/index-ja.html)
- [いまさらだけどGitを基本から分かりやすくまとめてみた](https://qiita.com/gold-kou/items/7f6a3b46e2781b0dd4a0)
- [git add ってなんのためにやるの？](https://kray.jp/blog/expound-git-add/)